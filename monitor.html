<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Monitor Trip | TRAVAIO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #topbar { padding: 10px; background: #f5f5f5; border-bottom: 1px solid #ddd; }
    #map { height: calc(100vh - 50px); width: 100%; }
    #status { font-size: 14px; margin-top: 5px; }
    .alert { color: red; font-weight: bold; }
  </style>
</head>

<body>
  <div id="topbar">
    <strong>Trip Monitor</strong> |
    <span id="trip-label">Loading...</span>
    <div id="status"></div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>

  <script>
    const API_BASE_URL = window.API_BASE_URL || 'http://localhost:5000';
    const token = localStorage.getItem('travaio_token');

    if (!token) {
      alert('Not logged in');
      window.location.href = 'login.html';
    }

    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    function setStatus(msg, isAlert = false) {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.className = isAlert ? 'alert' : '';
      if (isAlert) notifyUser(msg);
    }

    function notifyUser(msg) {
      if (!('Notification' in window)) return;
      if (Notification.permission === 'granted') {
        new Notification('TRAVAIO Alert', { body: msg });
      } else if (Notification.permission !== 'denied') {
        Notification.requestPermission().then(p => {
          if (p === 'granted') new Notification('TRAVAIO Alert', { body: msg });
        });
      }
    }

    const tripId = getQueryParam('tripId');
    if (!tripId) {
      alert('No tripId provided.');
    } else {
      let tripData = null;
      let routeControl = null;
      let userMarker = null;
      let routeLineLatLngs = [];

      async function fetchTrip() {
        const res = await fetch(`${API_BASE_URL}/trip/${tripId}`, {
          headers: { 'Authorization': 'Bearer ' + token }
        });

        if (!res.ok) {
          alert('Failed to load trip.');
          return;
        }

        tripData = await res.json();
        document.getElementById('trip-label').textContent = `${tripData.origin} → ${tripData.destination}`;
        await ensureTripCoords();
        initMapAndRoute();
      }

      async function geocode(place) {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(place)}`;
        const res = await fetch(url);
        const arr = await res.json();
        if (arr && arr.length > 0) {
          return { lat: Number(arr[0].lat), lng: Number(arr[0].lon) };
        }
        return null;
      }

      async function ensureTripCoords() {
        if (!tripData.originCoords) {
          const c = await geocode(tripData.origin);
          if (c) tripData.originCoords = c;
        }
        if (!tripData.destinationCoords) {
          const c = await geocode(tripData.destination);
          if (c) tripData.destinationCoords = c;
        }
        if (!tripData.originCoords || !tripData.destinationCoords) {
          alert('Could not geocode origin or destination.');
        }
      }

      let map;
      function initMapAndRoute() {
        const start = tripData.originCoords || { lat: 28.6139, lng: 77.2090 };
        map = L.map('map').setView([start.lat, start.lng], 10);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        if (tripData.originCoords && tripData.destinationCoords) {
          routeControl = L.Routing.control({
            waypoints: [
              L.latLng(tripData.originCoords.lat, tripData.originCoords.lng),
              L.latLng(tripData.destinationCoords.lat, tripData.destinationCoords.lng)
            ],
            routeWhileDragging: false,
            addWaypoints: false,
            draggableWaypoints: false,
            show: false
          })
          .on('routesfound', function(e) {
            const coords = e.routes[0].coordinates;
            routeLineLatLngs = coords.map(c => L.latLng(c.lat, c.lng));
            setStatus('Route loaded.');
          })
          .addTo(map);
        } else {
          setStatus('Missing coords, showing start only.', true);
        }

        startWatchingPosition();
      }

      const DEVIATION_THRESHOLD_METERS = 300;

      function calcMinDistanceToRoute(lat, lng) {
        if (!routeLineLatLngs.length) return Infinity;
        const current = L.latLng(lat, lng);
        let min = Infinity;
        for (let i = 0; i < routeLineLatLngs.length; i++) {
          const d = current.distanceTo(routeLineLatLngs[i]);
          if (d < min) min = d;
        }
        return min;
      }

      function startWatchingPosition() {
        if (!('geolocation' in navigator)) {
          alert('Geolocation not supported.');
          return;
        }

        navigator.geolocation.watchPosition(pos => {
          const { latitude, longitude } = pos.coords;
          if (!userMarker) {
            userMarker = L.marker([latitude, longitude], { title: 'You' }).addTo(map);
          } else {
            userMarker.setLatLng([latitude, longitude]);
          }

          const distance = calcMinDistanceToRoute(latitude, longitude);
          console.log('Distance to route (m):', distance);

          if (distance === Infinity) {
            setStatus('No route loaded yet…');
            return;
          }

          if (distance > DEVIATION_THRESHOLD_METERS) {
            setStatus('You are off your planned route!', true);
          } else {
            setStatus('On route.');
          }
        }, err => {
          console.error('geolocation error', err);
          setStatus('Location unavailable.', true);
        }, {
          enableHighAccuracy: true,
          maximumAge: 5000,
          timeout: 20000
        });
      }

      fetchTrip();
    }
  </script>
</body>
</html>